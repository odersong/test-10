#include<stdio.h>
//  %取模只能用于整数


//移位操作符  << 和 >>  只能用于整数
//int main()
//{
//	int b = 0;
//	int a = -3;
//	//00000000000000000000000000010000
//	b = a >> 1;
//	//00000000000000000000000000001000
//	//负数存储补码，打印原码，正数存储原码，打印原码
//	printf("%d ",b);
//	return 0;
//}

//1 .算术右移：右边丢弃，左边补原符号位  ；常用
//2 .逻辑右移：右边丢弃，左边补0
//3 .左移操作符简单，左边丢弃，右边补0

//int main()
//{
//	int a = -1;
//	//原码10000000000000000000000000000001
//	//反码11111111111111111111111111111110
//	//补码11111111111111111111111111111111
//	int b = a >> 1;
//	//补码11111111111111111111111111111111
//	//补码右移一位11111111111111111111111111111111
//	// 反码=补码-1：11111111111111111111111111111110
//	//打印原码10000000000000000000000000000001
//	printf("%d ", b);
//	return 0;
//}

//int main()
//{
//	int a = 5;
//	int b = a << 1;
//	printf("%d ", b);
//	return 0;
//}


//& 按位与    | 按位或     ^ 按位异或  他们的操作必须是整数，是二进制位
// 按位与&
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a & b;//&   1和0为0  1和1为1  0和0为0
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000001
//	//如果用负数，则用补码进行按位与，打印原码
//	printf("%d\n", c);
//	return 0;
//}


//按位或|
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a | b;// |   1和0为1  1和1为1  0和0为0
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000111
//	//如果用负数，则用补码进行按位与，打印原码
//	printf("%d\n", c);
//	return 0;
//}

//按位异或^
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;// ^   1和0为1  1和1为0  0和0为0
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000110
//	//如果用负数，则用补码进行按位与，打印原码
//	printf("%d\n", c);
//	return 0;
//}


//交换两个int变量的值，不能使用第三个变量，即a=3，b=5，交换后a=5，b=3
//方法一：    有问题，可能会溢出
//int main()
//{
//	int a = 3;
//	int b = 5;
//	a = a + b;
//	b = a - b;
//	a = a - b;
//	printf("a=%d b=%d\n", a, b);
//	return 0;
//}
//方法二：
//int main()
//{
//	int a = 3;
//	int b = 5;
//	a = a ^ b;
//	b = a ^ b;
//	//二次异或是本身
//	//可以把a和b按位异或得到的值比作密码,
//	//把密码和3按位异或得到5，把密码和5按位异或得到3
//	a = a ^ b;
//	printf("a=%d b=%d", a,b );
//	return 0;
//}


//编写代码：求一个整数存储在内存中的二进制中1的个数
//存在问题只能算正数
//int main()
//{
//	int a = 0;
//	int count = 0;
//	scanf_s("%d", &a);
//	//求a的补码有几个1
//	while (a)//代表a！=0进入循环，a=0跳出循环
//	{
//		if (a % 2 == 1)
//			count++;
//		a = a / 2;
//	}
//	printf("%d\n", count);
//	return 0;
//}

//编写代码：求一个整数存储在内存中的二进制中1的个数
// 方法一：
//int main()
//{
//	int a = 0;
//	int i = 0;
//	int count = 0;
//	scanf_s("%d", &a);
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((a >> i) & 1))
//			count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}

//方法二：  作业



//复合赋值符：+=		-=		*=		/=		%=		>>=		<<=		    
//			  &=		|=		^=
//int main()
//{
//	int a = 10;
//
//	a = a + 2;
//	a += 2;
//
//	a = a & 1;
//	a &= 1;
//	//复合赋值符的用法
//	return 0;
//}


//	a+b		有两个操作数，+ 为双目操作符	
//单目操作符：只有一个操作数：！逻辑反操作		- 负值		+ 正值		& 取地址	~ 对一个数的二进制按位取反
//							  sizeof 操作数的类型长度（以字节为单位）	--前置、后置--		++前置、后置++			
//							  * 间接访问操作符（解引操作符）		（）强制类型转换

//	 ！逻辑反操作的用处
//int main()
//{
//	int a = 10;
//	printf("%d\n", !a);//a=10， ！a=0，若a=0，！a=1
//	return 0;
//}

//int main()
//{
//	int a = 0;
//	if (a)
//	{
//		printf("a表示a为真进入if语句");
//	}
//	if (!a)
//	{
//		printf("!a表示a为假进入if语句");
//	}
//	return 0;
//}

//  -负号的用法：int a=-5或者	a = -a
//int main()
//{
//	int a = 1;
//	int i = 0;
//	int ret = 0;
//	for (i = 0; i <= 20; i++)
//	{
//		ret = i * a;
//		a = -a;//意思是a=1，变成a=-1，再变成a=1在for循环中循环下去
//		printf("%d\n", ret);
//		ret = 0;
//	}
//	return 0;
//}


//  & 取地址操作符   * 解引操作符
//int main()
//{
//	int a = 0;
//	int* i = &a;
//	*i = 20;
//	printf("%p\n", i);
//	printf("%p", &a);
//	return 0;
//}

//1.strlen 和sizeof没有什么联系
//2.strlen 是求字符串长度的，只能针对字符串长度    库函数，使用得引头文件
//3.sizeof 计算变量、数组类型所占内存空间的大小，单位是字节    操作符
//int main()
//{
//	int a = 0;
//	char c = 'r';
//	char* p = &c;
//	int arr[10] = { 0 };
//	printf("%d\n", sizeof(a));
//	//计算变量大小可以省咯括号（）
//	printf("%d\n", sizeof a);
//	printf("%d\n", sizeof(int));
//	//计算关键字大小需要括号括起来 例如：（int），还有以下的关键字要括起来
//
//	printf("%d\n", sizeof (c));
//	printf("%d\n", sizeof c);
//	printf("%d\n", sizeof (char));
//
//	printf("%d\n", sizeof (p));
//	printf("%d\n", sizeof p);
//	printf("%d\n", sizeof (char*));
//
//	printf("%d\n", sizeof (arr));
//	printf("%d\n", sizeof arr);
//	printf("%d\n", sizeof (int [10]));
//	return 0;
//}
//数组名去掉就是数组类型  例如：int arr[10] 他的类型是int [10]

//int main()
//{
//	short s = 0;
//	int a = 10;
//	printf("%d\n", sizeof(s = a + 5));//2,  
//	//s里面放得下15，sizeof（）里面的运算不是真实进行运算的，只是一个摆设， 注意有坑
//	printf("%d\n", s);//0
//	return 0;
//}

//  ~按（二进制）位取反  ：正数原码等于反码等于补码，直接按位取反，得到补码符号位为1，求其原码打印
//                       ：负数补码等于他原码的反码+1，对其补码进行按位取反，符号位为0，为正数，直接打印
//int main()
//{
//	int a = 0;
//	//00000000000000000000000000000000
//	int b = 1;
//	//00000000000000000000000000000001
//	printf("%d\n", ~a);
//	//按位取反得到补码：11111111111111111111111111111111打印需要原码10000000000000000000000000000001
//	printf("%d\n", ~b);
//	//按位取反得到补码：11111111111111111111111111111110打印需要原码10000000000000000000000000000010
//	return 0;
//}

//int main()
//{
//	int b = 0;
//	int c = 0;
//	int a = 11;// 把a变成15
//	//00000000000000000000000000001011
//	b = a | (1 << 2);
//	//(a):00000000000000000000000000001011
//	//(1):00000000000000000000000000000001
//	// (1<<2):00000000000000000000000000000100
//	//按位或得到：00000000000000000000000000001111
//	c = a ^ (1 << 2);//这个也可以把15变成11
//	printf("%d\n", b);//得到15
//	printf("%d\n", c);//得到15
//	return 0;
//}

//int main()
//{
//	int a = 15;
//	a = a & (~(1 << 2));
//	printf("%d\n", a);
//	return 0;
//}


//前置++，和后置++，--一样
//int main()
//{
//	int a = 10;
//	//printf("%d\n", ++a);//先++后打印
//	printf("%d\n", a++);//先打印后++
//	return 0;
//}

//（）强制转换
//int main()
//{
//	int a = (int)3.14;
//	printf("%d\n", a);
//	return 0;
//}
//单目操作符结束


//关系操作符   >	 >=	 	<		<=		!=		==

//逻辑操作符  && 逻辑与		||逻辑或
//int main()
//{
//	int a = 0;
//	int b = 10;
//	int c = a && b;//逻辑与是对数本身进行比较，0为假，10为真，逻辑与是假； 按位与是二进制进行比较
//	printf("%d\n", c);
//	return 0;
//}

//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;//a++是先使用在++，a=0，a&&b=0为假，后面都不运算了  有坑注意
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
//	return 0;
//}

//int main()
//{
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;//a=1，b=2+1 a&b=1 a=1+1 d=4  1&d=1  d=4+1，，，注意运算规律
//	i = a++ || ++b || d++;//逻辑或左边为真，停止运算，a=1+1 b=2 c=3 d=4     注意大坑
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
//	return 0;
//}
//逻辑与 左边为假不用继续算了
//逻辑或 左边为真不用继续算了


//条件操作符    exp1 ? exp2 : exp3     也叫三目操作符
//int main()
//{
//	int a = 0;
//	int b = 0;
//	printf("%d\n", a > 5 ? 3 : -3);
//	return 0;
//}

//求a，b的较大值
//int main()
//{
//	int a = 0;
//	int b = 5;
//	int max = a > b ? a : b;
//	printf("%d\n", max);
//	return 0;
//}


//逗号表达式   exp1,exp2,exp3,・・・expN
//逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);
//	printf("%d\n", c);
//	return 0;
//}

//
//a = get_val();
//count_val(a);
//while (a > 0)
//{
//	a = get_val();
//	count_val(a);
//}
//用（，）简化
//while (a = get_val(), count_val = (a), a > 0)
//{
//
//}


//下标引用、函数调用和结构成员
// 1 .[]下标引用操作符        操作数：一个数组名+一个索引值
//int arr[10];创建数组
//arr[9] = 10;实用下标引用操作符
//[]的两个操作数是arr和9

//函数调用操作符
//int get_max(int a, int b)
//{
//	return a > b ? a : b;
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//调用函数的时候的（）就是函数调用操作符    操作数是get_max,a,b有三个
//	int max = get_max(a, b);
//	printf("max=%d\n", max);
//	return 0;
//}


//struct  结构体
//创建结构体struct Stu类型
//     "."读作 "的"    "->"读作 "指向的"
struct Stu
{
	//成员变量
	char name[20];
	int age;
	char id[20];
};

int main()
{
	int a = 0;
	//使用struct Stu这个类型创建了一个学生对象sy，并初始化
	struct Stu sy = {"张三",20,"15255752176"};
	//printf("%s %d %s\n", sy.name ,sy.age,sy.id);
	//结构体变量.成员名    例： sy.name
	struct Stu* ps = &sy;
	//结构体指针->成员名
	printf(" %s\n %d\n %s\n", ps->name, ps->age, ps->id);//地址指向名字
	//printf("%s\n%d\n%s\n",(*ps).name,(*ps).age,(*ps).id);
	return 0;
}



//整型提升
// c的整型算数运算总是至少缺省整型类型的精度来进行的
// 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。
//提升为整形时，高位补充为符号位例如：00000001符号位是最左边的0，提升为整形是00000000000000000000000000000001

//   整形提升的意义：表达式的整形运算要在cpu的相应运算器件内执行，cpu内整型运算器（ALU）的操作数的字节长度一般就是
//   int的字节长度，同时也是cpu的通用寄存器的长度。
//   因此即使两个char类型的相加，在cpu执行时实际上也要先转换为cpu内整型操作数的标准长度。
//   同用cpu（general-purpose CPU）是难以直接实现两个8比特位字节直接相加运算（虽然机器指令中可能有这样字节相加指令）。
//   所以，表达式中各种长度可能小于int长度的整型值，都必须先转换成int或unsigned int，然后才送入CPU去执行运算。
//
//int main()
//{
//	char a = 3;
//	//00000000000000000000000000000011
//	//00000011  因为char型只能存放一个字节，八个比特位，只保留后八个
//	char b = 127;
//	//00000000000000000000000001111111
//	//01111111
//	char c = a + b;
//	//a+b先提升为整形计算，再保存8位
//	//00000000000000000000000000000011+00000000000000000000000001111111=00000000000000000000000010000010
//	//10000010-c
//	//在计算机中存放补码：11111111111111111111111110000010
//	             //反码 : 11111111111111111111111110000001
//	             //原码 ：10000000000000000000000001111110
//	//-126
//	printf("%d\n", c);
//	return 0;
//}

//整型提升实例
//只打印一个c
//int main()
//{
//	char a = 0xb6;//0x后面跟的是16进制整形
//	//b和6是16进制，char可以放八个字节，b换成二进制是1011，6是0110组合起来是：10110110
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		//比较也是运算
//		//a与0xb6进行比较，a就要整型提升为：11111111111111111111111110110110与0xb6不同，不打印
//		//可以这样想，0xb6是字符型1个字节，计算时提升为整形，与0xb6不相等
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000);
//	printf("c");
//	return 0;
//}

//int main()
//{
//	char a = 210;
//	printf("%d\n", a);
//	return 0;
//}

//int main()
//{
//	char c = 1;//  %u无符号十进制整数
//	printf("%u\n", sizeof(c));//1
//	printf("%u\n", sizeof(+c));//4 这个是先运算提升为整形再打印
//	printf("%u\n", sizeof(!c));//1  只有算术操作符、位操作符关系操作符会出现整型提升的效果
//	return 0;
//}


//  算术转换：如果某个操作符各个操作数属于不同的类型，那么除非其中一个操作数的转换位另一个操作数的
//  类型，否则操作就无法进行。下面的层次体系称为寻常算术转换。
//  long double 
//  double
//  float
//  unsigned long int
//  long int 
//  unsigned int
//  int
//  如果操作数的类型在上面这个列表中排名较低，那么首先要转换为另一个操作数的类型后执行运算。
//  警告：但是算术转换要合理，要不然会有一些潜在问题。


//  操作符的属性：1.操作符的优先级  2.操作符的结合性  3.是否控制求值顺序
//  两个相邻的操作符先执行哪个？取决于他们的优先级。
//  如果两个的优先级相同，取决于他们的结合性。
//找图表
//   a*b+c*d+e*f  是有问题的，不确定优先级
//   c + --c      也是有问题的，--c优先级高，第一种c=1，--c=0，0+1=1，另一种--c=0，c=0，0+0=0

//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);//这个也是有问题的，在不同编译器上答案都不一样。最好分布写。
//	printf("%d\n", ret);
//	return 0;
//}